{"componentChunkName":"component---src-templates-post-content-view-js","path":"/post/unity-dev-memo-(2)","result":{"data":{"markdownRemark":{"html":"<h2>Raycast</h2>\n<p>在使用滑鼠的 3D 遊戲中，幾乎與任何物件互動都需要使用滑鼠，判斷玩家游標的位置自然是非常重要且基礎的技術。然而相對 3D 世界的三維座標，存在於螢幕上的游標只有二維座標的 X 軸與 Y 軸兩個數據代表位置，這使得在遊戲世界中精準定位游標位置變得困難。</p>\n<p>不過，大多數想要在遊戲中取得游標位置時，都是為了與存在該位置的物件互動。這個物件就能成為定位游標的輔助工具，只要計算從玩家視角中的游標，是否真正與遊戲世界中的該物件重合即可。</p>\n<p>具體來說，這個判斷方式是從攝影機朝向滑鼠的二維座標射出一道直線，並判斷該射線所相交的物件。</p>\n<h3>Plane.Raycast</h3>\n<p>先從這個技術的最基本實作，也就是判斷滑鼠在純平面上的座標開始。</p>\n<pre><code class=\"language-csharp\">using UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Plane plane = new Plane (Vector3.up, 0);\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        float distance;\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        if(plane.Raycast(ray, out distance)){\n            mousePos = ray.GetPoint(distance);\n        }\n    }\n}\n</code></pre>\n<p>一行一行解讀：</p>\n<pre><code class=\"language-csharp\">Plane plane = new Plane (Vector3.up, 0);\n</code></pre>\n<p>從<a href=\"https://docs.unity3d.com/ScriptReference/Plane-ctor.html\">官方文件</a> 可以查到 Plane 的 constructor 是長這樣： <code>Plane (Vector3 inNormal, float distance)</code> 。</p>\n<p>以三維座標 (0, 0, 0) 為基準點，基於法線方向 <code>inNormal</code> 在距離基準點 <code>distance</code> 的位置創造一個平面。 <code>Vector3.up</code> 就等於 <code>Vector3 (0, 1, 0)</code> ，也就是筆直朝向 Y 軸上方的向量。這個 plane 不會顯示在遊戲中，如果想要用視覺理解 plane 的概念，可以直接在 Editor 中新增一個 rotation 與 position 都為 (0, 0, 0) 的 Plane，這兩個平面基本上相同。</p>\n<pre><code class=\"language-csharp\">   Camera camera;\n   Vector3 mousePos;\n   void Start () {\n       camera = Camera.main;\n   }\n</code></pre>\n<p>將目前使用的主攝影機存為變數，並預先設立儲存滑鼠位置用的變數。</p>\n<pre><code class=\"language-csharp\">void Update () {\n    float distance;\n    Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n    ...\n</code></pre>\n<p>在每次更新時，創建一個空的距離變數 <code>distance</code> ，以及一個射線變數 <code>ray</code> ，起點為攝影機的 near clipping plane，方向為滑鼠位置。</p>\n<p>攝影機的顯示範圍是一個上窄下寬的梯形，頂部距離攝影機較近且面積較小的平面就是 near clipping plane，底部較遠較大的平面就是 far clipping plane。玩家所謂的遊戲視窗大小基本上就等於 near clipping plane， <code>Camera.ScreenPointToRay</code> 也就是從 near clipping plane 射向 far clipping plane。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 800px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9ddf073bcf08fcfa2b3e4cefca28375d/fe4e9/unity_dev_memo_2_1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 89.27536231884058%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAA7EAAAOxAGVKw4bAAACbElEQVQ4y32Ta1PaQBiF8/f6oa1jayW3vW+y2TBgvDDAtCrqtMO1Ikpti9SAKDBOp/2HfZMIRWbamTPJZnef8569xNCSpmJasHxAiztY87RHkHXJrEGXiPF3jJPQw2GANEdaYCXJqqBnXRwbi1bKMDfypRYqpDhyc/uJTHjuIhOGAo7WZCQvGFhoX7g7yKpubRxtb5a3Ng5fvqhsvqq+fa2x7bNnM0EAg6WrUycfWQXzzYH0LmqH/X672Tg7PalWy1GxoPIeUtTyiRVwJ1EGa4CZI5HpYasc+ef14/vBxa9p73HS+znpzcf9h9uru+HloN+5Oq8fVfZ8AvOxZnbAbEMRW1G7squuu8ePk+59fD0fn89GHdA0boFmo9Ysbs/H3YfbTpTXAjGfCkmFR4WxG/Kv3RqU+j29uBv2xjefZ3Hr4TZT+/5HKxN4vd/X0t3WPKmpmCuINELhliPVODn4fvkxHkDaz9MYmOZk2EifzbubxnzUqdcOhJPTzAloJltibkALFiydnEC8VBDN02jYr03j+nycWIwHDfC66hz62ARgIdg5JDED2NbM8illrgcm1nZAXF0MS43TyvDL2WzUjr99KngY4GSTljDGEhMj+/YIw04e2UXb3HPhvN6FxIJrY38o5UsFD1zhRNRKZY9wRR1jGQY+fIIhD4yFHJZnwqlyJycX5KoE5sFzOBHAAjOOuCQkKcWe+ld4KAtzKNQwVsmnedSCFJJQsBCY+BQwa4UHOFkwNIy1PM8tbKjPEYMsycWiVhrEgsypo/1PeGmRbieCiwXyKAYeMqsF7Pyfz6ImfwV1AaOuSnfLBPAPjpLILuFRiLoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"unity dev memo 2 1\"\n        title=\"unity dev memo 2 1\"\n        src=\"/static/9ddf073bcf08fcfa2b3e4cefca28375d/7842b/unity_dev_memo_2_1.png\"\n        srcset=\"/static/9ddf073bcf08fcfa2b3e4cefca28375d/f8f3a/unity_dev_memo_2_1.png 200w,\n/static/9ddf073bcf08fcfa2b3e4cefca28375d/6a8a8/unity_dev_memo_2_1.png 400w,\n/static/9ddf073bcf08fcfa2b3e4cefca28375d/7842b/unity_dev_memo_2_1.png 800w,\n/static/9ddf073bcf08fcfa2b3e4cefca28375d/5ece7/unity_dev_memo_2_1.png 1200w,\n/static/9ddf073bcf08fcfa2b3e4cefca28375d/fe4e9/unity_dev_memo_2_1.png 1380w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>這兩個數值都可以從 camera 的 inspector 調整。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 474px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2f836733ac31ec72684262016169db69/a9480/unity_dev_memo_2_2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 267.72151898734177%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,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'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"unity dev memo 2 2\"\n        title=\"unity dev memo 2 2\"\n        src=\"/static/2f836733ac31ec72684262016169db69/a9480/unity_dev_memo_2_2.png\"\n        srcset=\"/static/2f836733ac31ec72684262016169db69/f8f3a/unity_dev_memo_2_2.png 200w,\n/static/2f836733ac31ec72684262016169db69/6a8a8/unity_dev_memo_2_2.png 400w,\n/static/2f836733ac31ec72684262016169db69/a9480/unity_dev_memo_2_2.png 474w\"\n        sizes=\"(max-width: 474px) 100vw, 474px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<pre><code class=\"language-csharp\">        ...\n        if(plane.Raycast(ray, out distance)){\n        mousePos = ray.GetPoint(distance);\n    }\n}\n</code></pre>\n<p>回到程式碼， <code>plane.Raycast</code> 中的 <code>out</code> 是另一個值得注意的地方。先看 <code>plane.Raycast</code> <a href=\"https://docs.unity3d.com/ScriptReference/Plane.Raycast.html\">函數本身</a>： <code>public bool Raycast(Ray ray, out float enter);</code></p>\n<p>這個函數的型別是 bool ，回傳引數 ray 是否與該 plane 相交。然而，部分函數提供額外的回傳值，取得值時必須提供一個空變數與 <code>out</code> 關鍵字一起作為引數輸入。 <code>plane.Raycast</code> 就是有提供 <code>out</code> 回傳值的函數之一，提供的是當相交發生時從 ray 起點至相交點的距離 <code>distance</code> 。因此這一段程式碼的作用是，判斷平面 plane 與 ray 是否有相交發生，如果有的話將距離儲存進 distance。現在射線起點，相交距離都知道了，就能計算出滑鼠位置便是從該射線上從起點開始距離 distance 的地方。</p>\n<p><img src=\"/9ab1f4863920df0af27365d6b58e1390/unity_dev_memo_2_3.gif\"></p>\n<p>以上就是在射線上增加元素使其可視化之後的展示，紅色點是射線起點 (<code>ray.GetPoint(0)</code> )，藍色點是與平面相交點（ <code>ray.GetPoint(distance)</code> ）。可以看見起點不是攝影機本身，而是在 near clipping plane 上。</p>\n<h3>Collider.Raycast</h3>\n<p>以上都是純平面的情況，實際在遊戲中常常有地形非單純平面的情況，此時可以使用 <code>TerrainCollider</code> 來計算射線與地形 terrain 的相交點。</p>\n<pre><code class=\"language-csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    TerrainCollider terrainCollider;\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n        terrainCollider = Terrain.activeTerrain.GetComponent&#x3C;TerrainCollider>();\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(terrainCollider.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n        }\n    }\n}\n</code></pre>\n<p>內容大致相同，只是這次判斷相交點的元素不是平面，而是地形碰撞體 <code>terrainCollider</code> ，而這個函數所提供的 out 相交資料也更豐富，不只有距離，而是一整個資料形態 <a href=\"https://docs.unity3d.com/ScriptReference/RaycastHit.html\">RaycastHit</a> ，包含 point, distance ,collider 等，point 即為射線與 <code>terrainCollider</code> 相交點。</p>\n<p><img src=\"/53fe811b6f10c3dc9d1b1828b8dbbded/unity_dev_memo_2_4.gif\"></p>\n<p>上圖就是在不規則地形使用 <code>terrainCollider.Raycast</code> 追蹤游標位置的展示，可以看見在右側遊戲畫面中游標移至山脈可見的南側時，左側的編輯器畫面也顯示游標位置的藍點直接跳過山脈北側，同時隨著地形一同起伏。</p>\n<h3>Physics.Raycast</h3>\n<p>以上兩種實作的前提都是射線相交的對象為特定單一物件。想要判斷射線是否相交非特定物件時，使用 <code>Physics.Raycast</code> 。這個函數會抓取引數的射線相交的第一個對象，且同樣提供 <code>out RaycastHit</code> 資料。</p>\n<pre><code class=\"language-csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class GetMousePos : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay(Input.mousePosition);\n        RaycastHit hitData;\n        if(Physics.Raycast(ray, out hitData, 1000)){\n            mousePos = hitData.point;\n                        GameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}\n</code></pre>\n<p><code>Physics.Raycast</code> 的提供距離引數做為判斷相交的最大距離，可以依照自己需求設定。</p>\n<p><img src=\"/decf69cf6840125171fd6f063c86e1dd/unity_dev_memo_2_5.gif\"></p>\n<p>上圖為使用 <code>Physics.Raycast</code> 追蹤游標互動物件的展示，使用 <code>RaycastHit.collider.transform.GameObject</code> 判斷射線的碰撞體的原物件之後就可以進行互動。</p>\n<h3>LayerMask in Physics.Raycast</h3>\n<p><code>Physics.Raycast</code> 還提供圖層引數過濾判斷射線相交對象。</p>\n<pre><code class=\"language-csharp\">using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class HighlightRayOrigin : MonoBehaviour {\n    Camera camera;\n    Vector3 mousePos;\n    LayerMask layerMask = 1 &#x3C;&#x3C; 8;\n\n    void Start () {\n        camera = Camera.main;\n    }\n\n    void Update () {\n        Ray ray = camera.ScreenPointToRay (Input.mousePosition);\n        RaycastHit hitData;\n        if (Physics.Raycast (ray, out hitData, 1000, layerMask)) {\n            mousePos = hitData.point;\n                        GameObject hitObj = hitData.collider.transform.gameObject;\n        }\n    }\n}\n</code></pre>\n<p><code>Physics.Raycast</code> 的 <code>layerMask</code> 引數就是指定圖層，只有在這個圖層中的物件才會觸發與射線相交的判斷。</p>\n<p>請注意，雖然這個引數的型別是 int，但其實是二進制的 int，所以直接輸入在編輯器中顯示的圖層編號是不會正常運作的，必須以 <code>&#x3C;&#x3C;</code> 運算子將指定編號以二進制方式儲存在變數中再傳遞給 <code>Physics.Raycast</code> 函數。</p>\n<p><img src=\"https://media.giphy.com/media/r505ukuetGAHNwCSZg/giphy.gif\"></p>\n<p>上圖是使用 LayerMask 過濾可互動物件的展示，只有上層物件位於可互動的圖層中，因此游標在地形或是下層物件時藍點都不會隨之移動。</p>","frontmatter":{"date":"2020-10-04","path":"/post/unity-dev-memo-(2)","title":"Unity dev memo (2)","tags":"Unity, Game Design"}},"allImageSharp":{"edges":[]}},"pageContext":{"slug":"/unity-dev-memo-(2)/"}}}